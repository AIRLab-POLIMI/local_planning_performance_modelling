run_index: &id001 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
#run_index: &id001 [7]
run_replication_index: &id003 [0]

environment_name: &id002 [7A-2]
#environment_name: &id002 [7A-2, airlab, fr079, intel, mexico, office_b]

combinatorial_parameters: [
  # {
  #   robot_model: [turtlebot3_waffle_performance_modelling],
  #   odometry_error: [[0.0, 0.0, 0.0, 0.0]],
  #   amcl_alpha_factor: [0],
  #   localization_node: [amcl],
  #   local_planner_node: [teb],
  #   global_planner_node: [global_planner],
  #   run_index: *id001,
  #   run_replication_index: *id003,
  #   environment_name: *id002,
  #   pedestrian_number: [0],
  #   pedestrian_max_vel: [0.3], 
  #   min_turning_radius: [0.0, 0.1]
  # },
  {
    robot_model: [turtlebot3_waffle_performance_modelling],
    # odometry_error: [[0.02, 0.0, 0.02, 0.0], [0.05, 0.0, 0.05, 0.0], [0.1, 0.0, 0.1, 0.0]],
    odometry_error: [[0.01, 0.0, 0.01, 0.0]], # 0.1 = 10% di errore. [v, correlazione tra v e w = 0, w, correlazione tra w e v = 0] odom legge la velocità come v_eff + v, questo per rendere più realistica la simulazione ()
    amcl_alpha_factor: [1.0],
    localization_node: [amcl],
    local_planner_node: [dwa],
    global_planner_node: [global_planner],
    run_index: *id001,
    run_replication_index: *id003,
    environment_name: *id002,
    pedestrian_number: [5],
    pedestrian_max_vel: [0.3],
    min_turning_radius: [0.0, 0.1],
    available_cpu_cores: [8]
  },
]


# Quando l'odometry error è pari a 0 è necessario settare amcl_alpha_factor a 0 per dire di non usarlo. Negli altri casi di odometry error != 0, allora alpha factor = 1.0